### Estructura de Carpetas del Proyecto

Asegúrate de que tu proyecto tenga la siguiente estructura de carpetas:

```
.
├── docker-compose.yml
├── db
│   └── init.sql
├── backend
│   ├── Dockerfile
│   └── app.py
└── frontend
    ├── Dockerfile
    ├── nginx.conf
    ├── index.html
    └── html5-qrcode.min.js
```

-----

### 1\. `docker-compose.yml`

Este archivo orquesta todos los servicios de tu aplicación.

```yaml
version: '3.8'

services:
  db:
    image: postgres:13
    restart: always
    environment:
      POSTGRES_DB: clubdb
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    volumes:
      - ./db/init.sql:/docker-entrypoint-initdb.d/init.sql
      - db_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user -d clubdb"]
      interval: 5s
      timeout: 5s
      retries: 5

  backend:
    build: ./backend
    restart: always
    environment:
      DB_HOST: db
      DB_NAME: clubdb
      DB_USER: user
      DB_PASSWORD: password
    depends_on:
      db:
        condition: service_healthy
    volumes:
      - ./backend:/app

  frontend:
    build: ./frontend
    restart: always
    ports:
      - "80:80" # El frontend expone el puerto 80 del host
      - "443:443" # El frontend expone el puerto 443 del host
    depends_on:
      backend:
        condition: service_started
    volumes:
      - ./frontend:/usr/share/nginx/html # Monta los archivos estáticos para desarrollo
      - ./frontend/nginx.conf:/etc/nginx/conf.d/default.conf # Monta la configuración de Nginx

  adminer:
    image: adminer:latest # Imagen oficial de Adminer
    container_name: tu_adminer
    restart: always
    ports:
      - "8080:8080" # Mapea el puerto 8080 del contenedor de Adminer al 8080 de tu máquina
    depends_on:
      db:
        condition: service_healthy # Asegura que la BD esté lista antes de iniciar Adminer

volumes:
  db_data:
```

-----

### 2\. `db/init.sql`

Este script inicializa tu base de datos con las tablas `events` y `tickets`.

```sql
-- db/init.sql (Actualizado)

-- Tabla de eventos
CREATE TABLE IF NOT EXISTS events (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    event_date DATE NOT NULL,
    location VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tabla de tickets (modificada para incluir event_id)
CREATE TABLE IF NOT EXISTS tickets (
    id SERIAL PRIMARY KEY,
    event_id INTEGER NOT NULL REFERENCES events(id) ON DELETE CASCADE, -- Clave foránea al evento
    user_id VARCHAR(255), -- Ahora puede ser opcional o generado
    seat VARCHAR(50) NOT NULL,
    qr_content VARCHAR(255) UNIQUE NOT NULL,
    scaned BOOLEAN DEFAULT FALSE,
    scaned_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

-----

### 3\. `backend/Dockerfile`

Dockerfile para la aplicación Flask del backend.

```dockerfile
# backend/Dockerfile
FROM python:3.9-slim-buster

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["python", "app.py"]
```

**Nota:** Asegúrate de tener un archivo `requirements.txt` en la carpeta `backend` con el siguiente contenido:

```
Flask
flask-cors
psycopg2-binary
qrcode
reportlab
```

-----

### 4\. `backend/app.py`

El código de la aplicación Flask, con las rutas corregidas para coincidir con la reescritura de Nginx.

```python
# backend/app.py (CORREGIDO)

import os
from flask import Flask, request, jsonify, send_file, url_for
from flask_cors import CORS
import psycopg2
from psycopg2.extras import DictCursor
import qrcode
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from io import BytesIO
import uuid
from datetime import datetime
from reportlab.lib.utils import ImageReader

app = Flask(__name__)
CORS(app)

# Configuración de la base de datos
DB_HOST = os.getenv('DB_HOST', 'db')
DB_NAME = os.getenv('DB_NAME', 'clubdb')
DB_USER = os.getenv('DB_USER', 'user')
DB_PASSWORD = os.getenv('DB_PASSWORD', 'password')

def get_db_connection():
    conn = psycopg2.connect(
        host=DB_HOST,
        database=DB_NAME,
        user=DB_USER,
        password=DB_PASSWORD
    )
    return conn

@app.route('/')
def home():
    return "Backend API del Club Deportivo"

# --- Endpoints para Eventos ---

# La ruta ahora es '/events' en lugar de '/api/events'
@app.route('/events', methods=['POST'])
def create_event():
    data = request.json
    name = data.get('name')
    event_date_str = data.get('event_date')
    location = data.get('location')

    if not all([name, event_date_str]):
        return jsonify({"error": "Faltan datos: name, event_date"}), 400

    try:
        event_date = datetime.strptime(event_date_str, '%Y-%m-%d').date()
    except ValueError:
        return jsonify({"error": "Formato de fecha inválido. Use YYYY-MM-DD"}), 400

    conn = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute(
            "INSERT INTO events (name, event_date, location) VALUES (%s, %s, %s) RETURNING id;",
            (name, event_date, location)
        )
        event_id = cur.fetchone()[0]
        conn.commit()
        cur.close()
        
        validation_link = f"/validate?event_id={event_id}"

        return jsonify({
            "status": "success",
            "message": "Evento creado con éxito",
            "event": {
                "id": event_id,
                "name": name,
                "event_date": event_date.strftime('%Y-%m-%d'),
                "location": location,
                "validation_link": validation_link
            }
        }), 201

    except psycopg2.Error as e:
        if conn: conn.rollback()
        return jsonify({"error": f"Error de base de datos: {e}"}), 500
    except Exception as e:
        return jsonify({"error": f"Error interno del servidor: {e}"}), 500
    finally:
        if conn: conn.close()

# La ruta ahora es '/events' en lugar de '/api/events'
@app.route('/events', methods=['GET'])
def get_all_events():
    conn = None
    try:
        conn = get_db_connection()
        cur = conn.cursor(cursor_factory=DictCursor)
        cur.execute("SELECT id, name, event_date, location, created_at FROM events ORDER BY event_date DESC, created_at DESC;")
        events = cur.fetchall()
        cur.close()
        conn.close()

        events_list = []
        for event in events:
            validation_link = f"/validate?event_id={event['id']}"
            events_list.append({
                "id": event['id'],
                "name": event['name'],
                "event_date": event['event_date'].strftime('%Y-%m-%d'),
                "location": event['location'],
                "created_at": event['created_at'].strftime('%Y-%m-%d %H:%M:%S'),
                "validation_link": validation_link
            })
        return jsonify(events_list), 200

    except psycopg2.Error as e:
        return jsonify({"error": f"Error de base de datos: {e}"}), 500
    except Exception as e:
        return jsonify({"error": f"Error interno del servidor: {e}"}), 500
    finally:
        if conn: conn.close()

# La ruta ahora es '/events/<int:event_id>' en lugar de '/api/events/<int:event_id>'
@app.route('/events/<int:event_id>', methods=['GET'])
def get_event_details(event_id):
    conn = None
    try:
        conn = get_db_connection()
        cur = conn.cursor(cursor_factory=DictCursor)
        cur.execute("SELECT id, name, event_date, location, created_at FROM events WHERE id = %s;", (event_id,))
        event = cur.fetchone()
        cur.close()
        conn.close()

        if event:
            validation_link = f"/validate?event_id={event['id']}"
            return jsonify({
                "id": event['id'],
                "name": event['name'],
                "event_date": event['event_date'].strftime('%Y-%m-%d'),
                "location": event['location'],
                "created_at": event['created_at'].strftime('%Y-%m-%d %H:%M:%S'),
                "validation_link": validation_link
            }), 200
        else:
            return jsonify({"error": "Evento no encontrado"}), 404

    except psycopg2.Error as e:
        return jsonify({"error": f"Error de base de datos: {e}"}), 500
    except Exception as e:
        return jsonify({"error": f"Error interno del servidor: {e}"}), 500
    finally:
        if conn: conn.close()

# --- Endpoints para Tickets (Modificados) ---

# La ruta ahora es '/ticket/create' en lugar de '/api/ticket/create'
@app.route('/ticket/create', methods=['POST'])
def create_ticket():
    data = request.json
    event_id = data.get('event_id')
    user_id = data.get('user_id') 
    seat = data.get('seat')

    if not all([event_id, seat]):
        return jsonify({"error": "Faltan datos: event_id, seat"}), 400

    conn = None
    try:
        conn = get_db_connection()
        cur = conn.cursor(cursor_factory=DictCursor)

        cur.execute("SELECT id FROM events WHERE id = %s;", (event_id,))
        if not cur.fetchone():
            return jsonify({"error": "El evento especificado no existe"}), 404

        if not user_id:
            user_id = f"CLIENT-{uuid.uuid4().hex[:8].upper()}" 

        qr_content = str(uuid.uuid4())

        cur.execute(
            "INSERT INTO tickets (event_id, user_id, seat, qr_content) VALUES (%s, %s, %s, %s) RETURNING id, user_id, event_id;",
            (event_id, user_id, seat, qr_content)
        )
        ticket_info = cur.fetchone()
        conn.commit()
        cur.close()

        ticket_id = ticket_info['id']
        generated_user_id = ticket_info['user_id']
        ticket_event_id = ticket_info['event_id']

        buffer = BytesIO()
        c = canvas.Canvas(buffer, pagesize=letter)
        width, height = letter

        c.drawString(50, height - 50, f"Ticket para el Club Deportivo - Evento ID: {ticket_event_id}")
        c.drawString(50, height - 70, f"ID de Ticket: {ticket_id}")
        c.drawString(50, height - 90, f"Usuario/Cliente: {generated_user_id}")

        cur_pdf = conn.cursor(cursor_factory=DictCursor)
        cur_pdf.execute("SELECT name, event_date FROM events WHERE id = %s;", (ticket_event_id,))
        event_details_for_pdf = cur_pdf.fetchone()
        cur_pdf.close()
        if event_details_for_pdf:
            c.drawString(50, height - 110, f"Evento: {event_details_for_pdf['name']} ({event_details_for_pdf['event_date'].strftime('%d/%m/%Y')})")
        else:
            c.drawString(50, height - 110, f"Evento ID: {ticket_event_id} (Fecha no disponible)")

        c.drawString(50, height - 130, f"Asiento: {seat}")

        qr_img = qrcode.make(qr_content)
        qr_img_buffer = BytesIO()
        qr_img.save(qr_img_buffer, format='PNG')
        qr_img_buffer.seek(0)

        qr_img_reader = ImageReader(qr_img_buffer)

        c.drawImage(qr_img_reader, width / 2 - 100, height - 300, width=200, height=200)
        c.drawString(50, height - 350, "Presente este QR para validación")

        c.save()
        buffer.seek(0)

        return send_file(buffer, download_name=f'ticket_event_{ticket_event_id}_user_{generated_user_id}.pdf', mimetype='application/pdf')

    except psycopg2.Error as e:
        if conn: conn.rollback()
        return jsonify({"error": f"Error de base de datos: {e}"}), 500
    except Exception as e:
        return jsonify({"error": f"Error interno del servidor: {e}"}), 500
    finally:
        if conn: conn.close()

# La ruta ahora es '/ticket/validate' en lugar de '/api/ticket/validate'
@app.route('/ticket/validate', methods=['POST'])
def validate_ticket():
    data = request.json
    qr_content = data.get('qr_content')
    event_id = data.get('event_id') 

    if not all([qr_content, event_id]):
        return jsonify({"error": "Faltan datos: qr_content, event_id"}), 400

    conn = None
    try:
        conn = get_db_connection()
        cur = conn.cursor(cursor_factory=DictCursor)
        cur.execute("SELECT * FROM tickets WHERE qr_content = %s AND event_id = %s;", (qr_content, event_id))
        ticket = cur.fetchone()
        cur.close()
        conn.close()

        if ticket:
            return jsonify({
                "status": "valid",
                "message": "Ticket válido",
                "ticket_info": {
                    "id": ticket['id'],
                    "event_id": ticket['event_id'],
                    "user_id": ticket['user_id'],
                    "seat": ticket['seat'],
                    "qr_content": ticket['qr_content'],
                    "scaned": ticket['scaned'],
                    "scaned_at": ticket['scaned_at'].strftime('%Y-%m-%d %H:%M:%S') if ticket['scaned_at'] else None
                }
            }), 200
        else:
            return jsonify({"status": "invalid", "message": "Ticket no encontrado para este evento o inválido"}), 404

    except psycopg2.Error as e:
        return jsonify({"error": f"Error de base de datos: {e}"}), 500
    except Exception as e:
        return jsonify({"error": f"Error interno del servidor: {e}"}), 500
    finally:
        if conn: conn.close()

# La ruta ahora es '/ticket/update_scaned' en lugar de '/api/ticket/update_scaned'
@app.route('/ticket/update_scaned', methods=['POST']) 
def update_ticket_scaned():
    data = request.json
    qr_content = data.get('qr_content')
    event_id = data.get('event_id') 

    if not all([qr_content, event_id]):
        return jsonify({"error": "Faltan datos: qr_content, event_id"}), 400

    conn = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("UPDATE tickets SET scaned = TRUE, scaned_at = NOW() WHERE qr_content = %s AND event_id = %s RETURNING id;", (qr_content, event_id))
        updated_ticket_id = cur.fetchone()

        if updated_ticket_id:
            conn.commit()
            cur.close()
            return jsonify({"status": "success", "message": "Ticket actualizado como escaneado", "ticket_id": updated_ticket_id[0]}), 200
        else:
            return jsonify({"status": "error", "message": "Ticket no encontrado para este evento o ya escaneado"}), 404

    except psycopg2.Error as e:
        if conn: conn.rollback()
        return jsonify({"error": f"Error de base de datos: {e}"}), 500
    except Exception as e:
        return jsonify({"error": f"Error interno del servidor: {e}"}), 500
    finally:
        if conn: conn.close()

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)
```

-----

### 5\. `frontend/Dockerfile`

Dockerfile para el servidor Nginx del frontend.

```dockerfile
# frontend/Dockerfile
FROM nginx:alpine

COPY nginx.conf /etc/nginx/conf.d/default.conf
COPY html5-qrcode.min.js /usr/share/nginx/html/
COPY index.html /usr/share/nginx/html/
```

-----

### 6\. `frontend/nginx.conf`

Configuración de Nginx para servir el frontend y proxy las solicitudes a la API.

```nginx
# frontend/nginx.conf
server {
    listen 80;
    listen 443 ssl;

    ssl_certificate /etc/nginx/certs/nginx.crt;
    ssl_certificate_key /etc/nginx/certs/nginx.key;

    server_name localhost;

    root /usr/share/nginx/html;
    index index.html index.htm;

    location / {
        try_files $uri $uri/ /index.html;
    }

    location /api/ {
        proxy_pass http://backend:5000/; # 'backend' es el nombre del servicio en docker-compose
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        # Elimina /api/ del path antes de enviar al backend
        rewrite ^/api/(.*)$ /$1 break;
    }
}
```

-----

### 7\. `frontend/index.html`

El archivo principal del frontend, con la lógica para la gestión de eventos y la validación condicional.

```html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestión de Eventos y Tickets</title>
    <script src="html5-qrcode.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { max-width: 900px; margin: auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: #0056b3; }

        form { margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; border-radius: 8px; background-color: #f9f9f9; }
        label { display: block; margin-bottom: 8px; font-weight: bold; }
        input[type="text"], input[type="date"], input[type="number"] { width: calc(100% - 22px); padding: 10px; margin-bottom: 15px; border: 1px solid #ccc; border-radius: 4px; }
        button { background-color: #007bff; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; margin-top: 10px; margin-right: 10px;}
        button:hover { background-color: #0056b3; }
        .success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; padding: 10px; border-radius: 4px; margin-top: 10px; }
        .error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; padding: 10px; border-radius: 4px; margin-top: 10px; }
        .info { background-color: #e2e3e5; color: #383d41; border: 1px solid #d6d8db; padding: 10px; border-radius: 4px; margin-top: 10px; }

        /* Estilos de la lista de eventos */
        #eventsList { list-style: none; padding: 0; }
        #eventsList li {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin-bottom: 10px;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        #eventsList li div { margin-right: 15px; }
        #eventsList li h3 { margin: 0 0 5px 0; font-size: 1.2em; }
        #eventsList li p { margin: 0; color: #555; font-size: 0.9em; }
        #eventsList li .event-actions button { margin-left: 5px; }
        #copyLinkButton { background-color: #28a745; }
        #copyLinkButton:hover { background-color: #218838; }

        /* Validación QR */
        #qr-reader-container { text-align: center; }
        #qr-reader { width: 100%; max-width: 500px; margin: 20px auto; border: 1px solid #ccc; border-radius: 5px; overflow: hidden; }
        #qr-reader__dashboard { background-color: #f0f0f0; padding: 10px; border-top: 1px solid #ccc; }
        #qr-reader__dashboard button { margin: 5px; }
        #qr-reader__scan_region { border: 2px solid #007bff; border-radius: 5px; }
        .validation-info { margin-top: 15px; font-weight: bold; }
        .validation-info.valid { background-color: #d4edda; color: #155724; border-color: #c3e6cb; padding: 10px; border-radius: 4px; }
        .validation-info.invalid { background-color: #f8d7da; color: #721c24; border-color: #f5c6cb; padding: 10px; border-radius: 4px; }
        #stopScannerButton { background-color: #dc3545; }
        #stopScannerButton:hover { background-color: #c82333; }

        /* Modal para crear tickets */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
        }
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto; /* 15% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            width: 80%; /* Could be more or less, depending on screen size */
            max-width: 500px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            position: relative;
        }
        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="mainContent">
            <h1>Gestión de Eventos del Club Deportivo</h1>

            <h2>Crear Nuevo Evento</h2>
            <form id="createEventForm">
                <label for="eventName">Nombre del Evento:</label>
                <input type="text" id="eventName" name="name" required><br>

                <label for="eventDate">Fecha del Evento (YYYY-MM-DD):</label>
                <input type="date" id="eventDate" name="event_date" required><br>

                <label for="eventLocation">Ubicación (Opcional):</label>
                <input type="text" id="eventLocation" name="location"><br>

                <button type="submit">Crear Evento</button>
            </form>
            <div id="eventResponse" class="info"></div>

            <h2>Eventos Existentes</h2>
            <ul id="eventsList">
                <li>Cargando eventos...</li>
            </ul>
        </div>

        <div id="validationContent" style="display: none;">
            <h1 id="validationHeader">Validación de Tickets para Evento: <span id="currentEventName"></span> (<span id="currentEventDate"></span>)</h1>
            <div id="qr-reader-container">
                <div id="qr-reader"></div>
                <button id="stopScannerButton" style="display: none;">Detener Escáner</button>
                <div id="validationResult" class="validation-info"></div>
            </div>
            <button onclick="window.location.href='/'">Volver a Gestión de Eventos</button>
        </div>

        <div id="createTicketModal" class="modal">
            <div class="modal-content">
                <span class="close-button">&times;</span>
                <h2 id="modalEventName">Crear Tickets para: </h2>
                <form id="createTicketForm">
                    <input type="hidden" id="modalEventId">
                    <label for="ticketUserId">ID de Cliente (Opcional, se generará si está vacío):</label>
                    <input type="text" id="ticketUserId" name="user_id"><br>

                    <label for="ticketSeat">Asiento:</label>
                    <input type="text" id="ticketSeat" name="seat" required><br>

                    <button type="submit">Generar Ticket y PDF</button>
                </form>
                <div id="ticketResponse" class="info"></div>
            </div>
        </div>

    </div>

    <script>
        // La URL base para las llamadas a la API (Nginx la proxeará al backend)
        const backendApiUrl = '/api'; 
        let qrScanner = null; // Variable global para la instancia del escáner
        let currentEventId = null; // ID del evento actual para la validación

        // --- Funciones de Utilidad ---
        function getQueryParam(param) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(param);
        }

        function showSection(sectionId) {
            document.getElementById('mainContent').style.display = 'none';
            document.getElementById('validationContent').style.display = 'none';
            document.getElementById(sectionId).style.display = 'block';
        }

        // --- Inicialización y Enrutamiento ---
        document.addEventListener('DOMContentLoaded', () => {
            const eventIdParam = getQueryParam('event_id');
            if (eventIdParam) {
                currentEventId = eventIdParam;
                showValidationView(currentEventId);
            } else {
                showEventManagementView();
                loadEvents();
            }
        });

        // --- Vista de Gestión de Eventos ---
        function showEventManagementView() {
            showSection('mainContent');
            stopQrScanner(); // Asegurarse de que el escáner esté detenido si se vuelve a la gestión
            document.getElementById('stopScannerButton').style.display = 'none';
        }

        // --- Vista de Validación de Tickets ---
        async function showValidationView(eventId) {
            showSection('validationContent');
            document.getElementById('stopScannerButton').style.display = 'block';
            document.getElementById('validationResult').textContent = ''; // Limpiar resultados anteriores

            // Obtener y mostrar detalles del evento
            try {
                // Se llama a /api/events/<eventId> y Nginx lo proxeará a /events/<eventId> en el backend
                const response = await fetch(`${backendApiUrl}/events/${eventId}`);
                const eventData = await response.json();
                if (response.ok) {
                    document.getElementById('currentEventName').textContent = eventData.name;
                    document.getElementById('currentEventDate').textContent = eventData.event_date;
                } else {
                    document.getElementById('validationHeader').textContent = `Error: Evento ${eventId} no encontrado.`;
                }
            } catch (error) {
                document.getElementById('validationHeader').textContent = `Error al cargar detalles del evento ${eventId}.`;
                console.error("Error fetching event details:", error);
            }

            initializeAndStartQrScanner();
        }

        // --- Crear Evento ---
        document.getElementById('createEventForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const name = document.getElementById('eventName').value;
            const event_date = document.getElementById('eventDate').value;
            const location = document.getElementById('eventLocation').value;
            const eventResponseDiv = document.getElementById('eventResponse');
            eventResponseDiv.className = 'info';
            eventResponseDiv.textContent = 'Creando evento...';

            try {
                // Se llama a /api/events y Nginx lo proxeará a /events en el backend
                const response = await fetch(`${backendApiUrl}/events`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, event_date, location })
                });

                const data = await response.json();
                if (response.ok) {
                    eventResponseDiv.className = 'success';
                    eventResponseDiv.innerHTML = `Evento "${data.event.name}" creado con éxito.<br>
                                                 Link de Validación: <a href="${data.event.validation_link}" target="_blank">${window.location.origin}${data.event.validation_link}</a>
                                                 <button onclick="copyToClipboard('${window.location.origin}${data.event.validation_link}')">Copiar Link</button>`;
                    document.getElementById('createEventForm').reset();
                    loadEvents(); // Recargar la lista de eventos
                } else {
                    eventResponseDiv.className = 'error';
                    eventResponseDiv.textContent = `Error al crear evento: ${data.error || response.statusText}`;
                }
            } catch (error) {
                eventResponseDiv.className = 'error';
                eventResponseDiv.textContent = `Error de conexión: ${error.message}`;
                console.error("Error creating event:", error);
            }
        });

        // --- Cargar Eventos ---
        async function loadEvents() {
            const eventsList = document.getElementById('eventsList');
            eventsList.innerHTML = '<li>Cargando eventos...</li>';
            try {
                // Se llama a /api/events y Nginx lo proxeará a /events en el backend
                const response = await fetch(`${backendApiUrl}/events`);
                const events = await response.json();
                eventsList.innerHTML = ''; // Limpiar mensaje de carga

                if (events.length === 0) {
                    eventsList.innerHTML = '<li>No hay eventos creados.</li>';
                    return;
                }

                events.forEach(event => {
                    const li = document.createElement('li');
                    li.innerHTML = `
                        <div>
                            <h3>${event.name}</h3>
                            <p>Fecha: ${event.event_date}</p>
                            <p>Ubicación: ${event.location || 'N/A'}</p>
                            <p>ID: ${event.id}</p>
                        </div>
                        <div class="event-actions">
                            <button onclick="openCreateTicketModal(${event.id}, '${event.name}', '${event.event_date}')">Dar de Alta Clientes</button>
                            <button onclick="copyToClipboard('${window.location.origin}${event.validation_link}')">Copiar Link de Validación</button>
                            <button onclick="window.location.href='${event.validation_link}'">Ir a Validación</button>
                        </div>
                    `;
                    eventsList.appendChild(li);
                });
            } catch (error) {
                eventsList.innerHTML = '<li class="error">Error al cargar eventos.</li>';
                console.error("Error loading events:", error);
            }
        }

        // --- Funciones para el Modal de Crear Tickets ---
        const createTicketModal = document.getElementById('createTicketModal');
        const closeButton = document.querySelector('.close-button');
        const modalEventName = document.getElementById('modalEventName');
        const modalEventId = document.getElementById('modalEventId');
        const createTicketForm = document.getElementById('createTicketForm');
        const ticketResponse = document.getElementById('ticketResponse');

        closeButton.onclick = () => {
            createTicketModal.style.display = 'none';
        }

        window.onclick = (event) => {
            if (event.target == createTicketModal) {
                createTicketModal.style.display = 'none';
            }
        }

        function openCreateTicketModal(eventId, eventName, eventDate) {
            modalEventName.textContent = `Crear Tickets para: ${eventName} (${eventDate})`;
            modalEventId.value = eventId;
            ticketResponse.className = 'info';
            ticketResponse.textContent = ''; // Limpiar mensaje anterior
            document.getElementById('ticketUserId').value = ''; // Limpiar ID de usuario
            document.getElementById('ticketSeat').value = ''; // Limpiar asiento
            createTicketModal.style.display = 'block';
        }

        createTicketForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const event_id = document.getElementById('modalEventId').value;
            const user_id = document.getElementById('ticketUserId').value;
            const seat = document.getElementById('ticketSeat').value;

            ticketResponse.className = 'info';
            ticketResponse.textContent = 'Generando ticket...';

            try {
                const payload = { event_id, seat };
                if (user_id) { // Solo añadir user_id si no está vacío
                    payload.user_id = user_id;
                }

                // Se llama a /api/ticket/create y Nginx lo proxeará a /ticket/create en el backend
                const response = await fetch(`${backendApiUrl}/ticket/create`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `ticket_event_${event_id}_${user_id || 'generado'}.pdf`;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    window.URL.revokeObjectURL(url);

                    ticketResponse.className = 'success';
                    ticketResponse.textContent = 'Ticket generado y PDF descargado con éxito.';
                    createTicketForm.reset(); // Limpiar formulario del modal
                } else {
                    const errorData = await response.json();
                    ticketResponse.className = 'error';
                    ticketResponse.textContent = `Error al generar ticket: ${errorData.error || response.statusText}`;
                }
            } catch (error) {
                ticketResponse.className = 'error';
                ticketResponse.textContent = `Error de conexión: ${error.message}`;
                console.error("Error al crear ticket:", error);
            }
        });

        // --- Funcionalidad de Escaneo y Validación QR ---
        function initializeAndStartQrScanner() {
            if (typeof Html5Qrcode === 'undefined') {
                document.getElementById('validationResult').className = 'validation-info error';
                document.getElementById('validationResult').textContent = 'Error: La librería del escáner QR no se ha cargado correctamente.';
                return;
            }

            if (!qrScanner) {
                qrScanner = new Html5Qrcode("qr-reader");
            }

            if (qrScanner.isScanning) {
                console.log("Escáner ya está activo, no se necesita iniciar de nuevo.");
                return;
            }

            // Opciones de configuración del escáner
            const config = {
                fps: 10,
                qrbox: { width: 250, height: 250 },
                // Preferir la cámara trasera/entorno si está disponible
                facingMode: "environment" 
            };

            qrScanner.start(
                config,
                qrCodeSuccessCallback,
                (errorMessage) => {
                    // No mostrar errores de frames si no hay QR detectado, solo errores de cámara.
                    if (errorMessage.includes("NotAllowedError") || errorMessage.includes("NotFoundError") || errorMessage.includes("Permission denied")) {
                        document.getElementById('validationResult').className = 'validation-info error';
                        document.getElementById('validationResult').textContent = 'Error: No se pudo acceder a la cámara. Verifique permisos o si hay una cámara disponible.';
                    }
                }
            ).catch(err => {
                document.getElementById('validationResult').className = 'validation-info error';
                document.getElementById('validationResult').textContent = `Error al iniciar el escáner QR. (Detalle: ${err.message || err})`;
                console.error("Error starting QR scanner:", err);
            });
        }

        const qrCodeSuccessCallback = async (decodedText, decodedResult) => {
            console.log(`QR Scanned: ${decodedText}`);
            stopQrScanner(); // Detener el escáner después de una lectura exitosa
            document.getElementById('validationResult').textContent = 'Validando QR...';

            try {
                // Se llama a /api/ticket/validate y Nginx lo proxeará a /ticket/validate en el backend
                const response = await fetch(`${backendApiUrl}/ticket/validate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ qr_content: decodedText, event_id: currentEventId })
                });

                const data = await response.json();
                const validationResultDiv = document.getElementById('validationResult');

                if (response.ok) {
                    if (data.ticket_info.scaned) {
                        validationResultDiv.className = 'validation-info invalid'; // Usar invalid para ya escaneado
                        validationResultDiv.textContent = `Ticket ya escaneado: ${data.ticket_info.scaned_at ? new Date(data.ticket_info.scaned_at).toLocaleString() : 'N/A'}. Pertenece a ${data.ticket_info.user_id}, Asiento: ${data.ticket_info.seat}`;
                    } else {
                        validationResultDiv.className = 'validation-info valid';
                        validationResultDiv.innerHTML = `Ticket válido para el evento ${currentEventId}: <br>
                        ID: ${data.ticket_info.id}<br>
                        Usuario/Cliente: ${data.ticket_info.user_id}<br>
                        Asiento: ${data.ticket_info.seat}`;

                        // Marcar el ticket como escaneado
                        // Se llama a /api/ticket/update_scaned y Nginx lo proxeará a /ticket/update_scaned en el backend
                        await fetch(`${backendApiUrl}/ticket/update_scaned`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ qr_content: decodedText, event_id: currentEventId })
                        });
                    }
                } else {
                    validationResultDiv.className = 'validation-info invalid';
                    validationResultDiv.textContent = `Ticket inválido para este evento: ${data.message || response.statusText}`;
                }
            } catch (error) {
                document.getElementById('validationResult').className = 'validation-info error';
                document.getElementById('validationResult').textContent = `Error de conexión con la API: ${error.message}`;
                console.error("Error al validar ticket:", error);
            } finally {
                // Reanudar el escáner después de un breve retraso para permitir nuevas validaciones
                setTimeout(initializeAndStartQrScanner, 3000);
            }
        };

        function stopQrScanner() {
            if (qrScanner && qrScanner.isScanning) {
                qrScanner.stop().catch(err => {
                    console.error("Error al detener el escáner QR:", err);
                });
            }
        }

        document.getElementById('stopScannerButton').addEventListener('click', () => {
            stopQrScanner();
            document.getElementById('validationResult').textContent = 'Escáner detenido.';
            document.getElementById('stopScannerButton').style.display = 'none';
        });

        // --- Funciones de Portapapeles ---
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                alert('¡Enlace copiado al portapapeles!');
            }).catch(err => {
                console.error('Error al copiar el texto: ', err);
                alert('No se pudo copiar el enlace. Por favor, cópielo manualmente: ' + text);
            });
        }
    </script>
</body>
</html>
```

-----

### 8\. `frontend/html5-qrcode.min.js`

Asegúrate de tener este archivo JavaScript de la librería HTML5-QRCODE en la misma carpeta `frontend`. Puedes descargarlo de su repositorio oficial (busca "html5-qrcode github" y ve a la sección de releases).

-----

### Pasos para el Despliegue y Pruebas:

1.  **Guarda todos los archivos** en sus respectivas ubicaciones dentro de tu estructura de carpetas.
2.  **Si ya tenías el proyecto funcionando y has cambiado `db/init.sql`**:
      * Detén y elimina los contenedores y el volumen de la base de datos para asegurar que la nueva estructura de DB se aplique:
        ```bash
        docker-compose down # O "docker compose down" si usas la versión más nueva
        docker volume ls    # Para identificar el nombre exacto de tu volumen de DB (ej: club_depor_db_data)
        docker volume rm <nombre_de_tu_volumen_db>
        ```
3.  **Construye y levanta todos los servicios de Docker:**
    ```bash
    docker-compose up --build -d # O "docker compose up --build -d"
    ```
    El `--build` es crucial para que Docker reconstruya las imágenes del backend y frontend con los últimos cambios de código y configuración.
4.  **Accede a la aplicación:**
      * Una vez que todos los servicios estén en `Up` (y `healthy` si aplica), abre tu navegador y ve a `https://localhost` (o `http://localhost` si no tienes certificados SSL configurados en tu sistema local para Nginx).

¡Con estos códigos, tu proyecto debería estar funcionando con todas las nuevas características\!